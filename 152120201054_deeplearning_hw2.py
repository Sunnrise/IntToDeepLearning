# -*- coding: utf-8 -*-
"""152120201054_DeepLearning_Hw2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nHLHu5ovmguvShxeisBJGVcFh1jgAEv1
"""

import zipfile

# Fırsly I added a zipfile from computer.
zip_path = '/content/HW3_percep.zip'

# Specify the extraction directory
extraction_path = '/content/extracted_folder/'

# Extract the ZIP file
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extraction_path)
    # /content/extracted_folder/CaltechTinySplit then I carry files from here to main folder list (test and train)

import os
from PIL import Image
import numpy as np

main_folder = "/content/extracted_folder/CaltechTinySplit/train"
classes = ["flamingo", "pizza"]

data = []
labels = []

for i, class_name in enumerate(classes):
    class_folder = os.path.join(main_folder, class_name)
    for filename in os.listdir(class_folder):
        img_path = os.path.join(class_folder, filename)
        img = Image.open(img_path)
        img_array = np.array(img)  # Convert image to numpy array
        data.append(img_array)
        labels.append(i)  # Assign label based on the class index


# 'data' now contains the image data, and 'labels' contains the corresponding class labels.

from PIL import Image
import os
import numpy as np

def load_images(folder_path, image_size=(128, 128)):
    data = []
    labels = []

    for class_label, class_name in enumerate(os.listdir(folder_path)):
        class_folder = os.path.join(folder_path, class_name)
        for filename in os.listdir(class_folder):
            img_path = os.path.join(class_folder, filename)
            img = Image.open(img_path).resize(image_size)
            img_array = np.array(img).reshape(-1)  # Convert image to 1D vector
            data.append(img_array)
            labels.append(class_label)

    return np.array(data), np.array(labels)

# Load training data
train_folder = "/content/train"
train_data, train_labels = load_images(train_folder)

# Load test data
test_folder = "/content/test_folder"
test_data, _ = load_images(test_folder)

# Now 'train_data' contains the training image vectors, 'train_labels' contains corresponding labels,
# and 'test_data' contains the test image vectors.

# Further steps would include training a perceptron model using 'train_data' and 'train_labels',
# and then using the trained model to predict labels for 'test_data'.

import numpy as np
from sklearn.utils import shuffle
import cv2
# Activation functions
def tanh(x):
    return (np.exp(x) - np.exp(-x))/(np.exp(x) + np.exp(-x))

def softplus(x):
    return np.log(1 + np.exp(x))

def mish(x):
    return x * tanh(softplus(x))

def dmish(x):
    omega = np.exp(3*x) + 4*np.exp(2*x) + (6+4*x)*np.exp(x) + 4*(1 + x)
    delta = 1 + pow((np.exp(x) + 1), 2)
    derivative = np.exp(x) * omega / pow(delta, 2)
    return derivative

# Training function
def trainPerceptron(inputs, t, weights, rho, iterNo):
    # Add bias to input vector
    inputs = np.concatenate((inputs, np.ones((inputs.shape[0], 1))), axis=1)

    for _ in range(iterNo):
        # Shuffle inputs and targets
        inputs, t = shuffle(inputs, t)

        for i in range(len(inputs)):
            x = inputs[i]
            target = t[i]

            # Compute output
            output = mish(np.dot(x, weights))

            # Compute error
            error = target - output

            # Compute weight updates
            delta_w = rho * error * dmish(output) * x

            # Update weights
            weights += delta_w

    # Save weights
    np.save('weights.npy', weights)

import numpy as np

def trainPerceptron(inputs, labels, learning_rate=0.01, epochs=100):
    # Initialize weights and bias
    weights = np.zeros(inputs.shape[1])
    bias = 0

    # For each epoch
    for _ in range(epochs):
        # For each sample in the training set
        for input, label in zip(inputs, labels):
            # Compute output
            output = np.dot(input, weights) + bias > 0

            # Update weights and bias
            weights += learning_rate * (label - output) * input
            bias += learning_rate * (label - output)

    return weights, bias

import numpy as np
from PIL import Image

def feed_forward(sample, weights):
    return np.dot(sample, weights)

def testPerceptron(sample_test, weights):
    # Load weights
    weights = np.load(weights)

    # Read a test image
    img = Image.open(sample_test)
    img = np.array(img).flatten()

    # Feed forward process of perceptron algorithm
    output = feed_forward(img, weights)

    # Return predicted value
    return np.argmax(output)

def calculate_accuracy(predicted_labels, true_labels):
    correct_predictions = np.sum(predicted_labels == true_labels)
    total_predictions = len(true_labels)
    accuracy = correct_predictions / total_predictions
    return accuracy

import numpy as np
from PIL import Image
from sklearn.utils import shuffle
from sklearn.preprocessing import OneHotEncoder

# Activation function
def mish(x):
    return x * np.tanh(np.log(1 + np.exp(x)))

# Derivative of activation function
def dmish(x):
    omega = np.exp(3*x) + 4*np.exp(2*x) + (6+4*x)*np.exp(x) + 4*(1 + x)
    delta = 1 + pow((np.exp(x) + 1), 2)
    derivative = np.exp(x) * omega / pow(delta, 2)
    return derivative

# Training function
def trainPerceptron(inputs, t, weights, rho, iterNo):
    # Add bias to inputs
    inputs = np.concatenate((inputs, np.ones((inputs.shape[0], 1))), axis=1)

    # Shuffle inputs
    inputs, t = shuffle(inputs, t)

    # For each epoch
    for _ in range(iterNo):
        # For each sample in the training set
        for input, label in zip(inputs, t):
            # Compute output
            output = mish(np.dot(input, weights))

            # Update weights
            weights += rho * (label - output) * dmish(np.dot(input, weights)) * input

    # Save weights
    np.save('weights.npy', weights)

# Testing function
import os

def testPerceptron(test, weights):
    # Load weights
    weights = np.load(weights)

    # Initialize a list to store the predicted labels
    predicted_labels = []

    # For each image in the test folder
    for filename in os.listdir(test):
        # Read the image
        img = Image.open(os.path.join(test, filename))
        img = np.array(img).flatten()

        # Add bias to input
        img = np.append(img, 1)

        # Compute output
        output = mish(np.dot(img, weights))

        # Add the predicted label to the list
        predicted_labels.append(np.argmax(output))

    return predicted_labels

def calculate_accuracy(predicted_labels, true_labels):
    correct_predictions = np.sum(predicted_labels == true_labels)
    total_predictions = len(true_labels)
    accuracy = correct_predictions / total_predictions
    return accuracy

import numpy as np
from PIL import Image
from sklearn.utils import shuffle
from sklearn.preprocessing import OneHotEncoder

# Aktivasyon fonksiyonu
def mish(x):
    return x * np.tanh(np.log(1 + np.exp(x)))

# Aktivasyon fonksiyonunun türevi
def dmish(x):
    omega = np.exp(3*x) + 4*np.exp(2*x) + (6+4*x)*np.exp(x) + 4*(1 + x)
    delta = 1 + pow((np.exp(x) + 1), 2)
    derivative = np.exp(x) * omega / pow(delta, 2)
    return derivative

# Eğitim fonksiyonu
def trainPerceptron(inputs, t, weights, rho, iterNo):
    # Girişlere bias ekleyin
    inputs = np.concatenate((inputs, np.ones((inputs.shape[0], 1))), axis=1)

    # Girişleri karıştırın
    inputs, t = shuffle(inputs, t)

    # Her bir epoch için
    for _ in range(iterNo):
        # Eğitim setindeki her bir örnek için
        for input, label in zip(inputs, t):
            # Çıktıyı hesaplayın
            output = mish(np.dot(input, weights))

            # Ağırlıkları güncelleyin
            weights += rho * (label - output) * dmish(np.dot(input, weights)) * input

    # Ağırlıkları kaydedin
    np.save('weights.npy', weights)

# Test fonksiyonu
def testPerceptron(test_folder, weights):
    # Ağırlıkları yükleyin
    weights = np.load(weights)

    # Tahmin edilen etiketleri saklamak için bir liste başlatın
    predicted_labels = []

    # Test klasöründeki her bir görüntü için
    for filename in os.listdir(test_folder):
        # Görüntüyü okuyun
        img = Image.open(os.path.join(test_folder, filename))
        img = np.array(img).flatten()

        # Girişe bias ekleyin
        img = np.append(img, 1)

        # Çıktıyı hesaplayın
        output = mish(np.dot(img, weights))

        # Tahmin edilen etiketi listeye ekleyin
        predicted_labels.append(np.argmax(output))

    return predicted_labels

